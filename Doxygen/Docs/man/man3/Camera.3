.TH "Camera" 3 "Fri Mar 29 2013" "Version 31337" "HyperGrafx" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Camera \- 
.PP
The \fBCamera\fP class represents a logical camera in a model view, which posesses a current viewing angle and an absolute position in space as its state\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Camera\&.hpp>\fP
.PP
Inherits \fBObject\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBDirection\fP { \fBDIR_FORWARD\fP, \fBDIR_BACKWARD\fP, \fBDIR_LEFT\fP, \fBDIR_RIGHT\fP, \fBDIR_UP\fP, \fBDIR_DOWN\fP, \fBDIR_END\fP, \fBDIR_BEGIN\fP =  DIR_FORWARD }"
.br
.RI "\fIThe Direction enumeration lists all of the possible directions the camera may travel in\&. \fP"
.ti -1c
.RI "enum \fBViewType\fP { \fBPERSPECTIVE\fP, \fBORTHO\fP, \fBORTHO2D\fP, \fBIDENTITY\fP, \fBFRUSTUM\fP }"
.br
.RI "\fIThe ViewType enumeration lists the various possibilities for the current viewing mode that can be switched between\&. \fP"
.ti -1c
.RI "enum \fBUniforms\fP { \fBBEGIN\fP =  Object::END, \fBTRANSLATION\fP =  BEGIN, \fBROTATION\fP, \fBVIEW\fP, \fBCTM\fP, \fBEND\fP }"
.br
.RI "\fIThe glsl_var enumeration lists the various variables the \fBCamera\fP class is capable of sending to the shader\&. \fP"
.ti -1c
.RI "typedef enum \fBCamera::Direction\fP \fBDirection\fP"
.br
.RI "\fIThe Direction enumeration lists all of the possible directions the camera may travel in\&. \fP"
.ti -1c
.RI "typedef enum \fBCamera::ViewType\fP \fBViewType\fP"
.br
.RI "\fIThe ViewType enumeration lists the various possibilities for the current viewing mode that can be switched between\&. \fP"
.ti -1c
.RI "typedef enum \fBCamera::Uniforms\fP \fBUniform\fP"
.br
.RI "\fIThe glsl_var enumeration lists the various variables the \fBCamera\fP class is capable of sending to the shader\&. \fP"
.ti -1c
.RI "typedef const unsigned int \fBUniformEnum\fP"
.br
.RI "\fIThe \fBObject\fP class takes advantage of child-extendible enumerations\&. \fP"
.ti -1c
.RI "typedef std::map
.br
< \fBObject::UniformEnum\fP, 
.br
std::string > \fBUniformMap\fP"
.br
.RI "\fIWe store mappings of Uniform Enumerations, The desired function of the var, to strings, the names of the variables\&. \fP"
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCamera\fP (const std::string &\fBname\fP, GLuint gShader, float \fBx\fP=0\&.0, float \fBy\fP=0\&.0, float \fBz\fP=0\&.0)"
.br
.RI "\fIInitialization Constructor; sets the x,y,z coordinates explicitly\&. \fP"
.ti -1c
.RI "\fBCamera\fP (const std::string &\fBname\fP, GLuint gShader, \fBvec3\fP &in)"
.br
.RI "\fIInitialization Constructor, uses a vec3 as its initial coordinates\&. \fP"
.ti -1c
.RI "\fBCamera\fP (const std::string &\fBname\fP, GLuint gShader, \fBvec4\fP &in)"
.br
.RI "\fIInitialization Constructor, uses a vec4 as its initial coordinates\&. \fP"
.ti -1c
.RI "virtual \fB~Camera\fP (void)"
.br
.RI "\fIDefault destructor\&. \fP"
.ti -1c
.RI "void \fBx\fP (const float &in, const bool &update=true)"
.br
.RI "\fISets the x coordinate of the camera\&. \fP"
.ti -1c
.RI "void \fBy\fP (const float &in, const bool &update=true)"
.br
.RI "\fISets the y coordinate of the camera\&. \fP"
.ti -1c
.RI "void \fBz\fP (const float &in, const bool &update=true)"
.br
.RI "\fISets the z coordinate of the camera\&. \fP"
.ti -1c
.RI "void \fBpos\fP (const float &\fBx\fP, const float &\fBy\fP, const float &\fBz\fP, const bool &update=true)"
.br
.RI "\fISets the absolute position of the camera\&. \fP"
.ti -1c
.RI "void \fBpos\fP (const \fBvec3\fP &in, const bool &update=true)"
.br
.RI "\fISets the absolute position of the camera\&. \fP"
.ti -1c
.RI "void \fBpos\fP (const \fBvec4\fP &in, const bool &update=true)"
.br
.RI "\fISets the absolute position of the camera\&. \fP"
.ti -1c
.RI "void \fBdX\fP (const float &by, const bool &update=true)"
.br
.RI "\fIMoves the camera along the x axis\&. \fP"
.ti -1c
.RI "void \fBdY\fP (const float &by, const bool &update=true)"
.br
.RI "\fIMoves the camera along the y axis\&. \fP"
.ti -1c
.RI "void \fBdZ\fP (const float &by, const bool &update=true)"
.br
.RI "\fIMoves the camera along the z axis\&. \fP"
.ti -1c
.RI "void \fBdPos\fP (const float &\fBx\fP, const float &\fBy\fP, const float &\fBz\fP)"
.br
.RI "\fIMoves the camera along the x, y, and z axes\&. \fP"
.ti -1c
.RI "void \fBdPos\fP (const \fBvec3\fP &by)"
.br
.RI "\fIMoves the camera along the x, y, and z axes\&. \fP"
.ti -1c
.RI "void \fBdPos\fP (const \fBvec4\fP &by)"
.br
.RI "\fIMoves the camera along the x, y, and z axes\&. \fP"
.ti -1c
.RI "void \fBfieldOfView\fP (const float &fovy)"
.br
.RI "\fIfieldOfView sets the current camera Field-of-view angle\&. \fP"
.ti -1c
.RI "float \fBfieldOfView\fP (void) const "
.br
.RI "\fI\fBfieldOfView()\fP gets the current camera Field-of-view angle\&. \fP"
.ti -1c
.RI "void \fBadjustFieldOfView\fP (const float &by)"
.br
.RI "\fIadjustFieldOfView adjusts the field of view angle up or down by an amount\&. \fP"
.ti -1c
.RI "void \fBchangePerspective\fP (const \fBViewType\fP &vType)"
.br
.RI "\fIchangePerspective changes the current perspective of the camera\&. \fP"
.ti -1c
.RI "void \fBrefreshPerspective\fP (void)"
.br
.RI "\fIrefreshPerspective re-generates the current view/perspective matrix of the camera\&. \fP"
.ti -1c
.RI "void \fBviewport\fP (size_t _X, size_t _Y, size_t _width, size_t _height)"
.br
.RI "\fIviewport instructs this camera what his expected drawing window will be\&. \fP"
.ti -1c
.RI "void \fBsway\fP (const float &by)"
.br
.RI "\fIAdjusts the camera's x coordinate relative to its current position\&. \fP"
.ti -1c
.RI "void \fBsurge\fP (const float &by)"
.br
.RI "\fIAdjusts the camera's z coordinate relative to its current position\&. \fP"
.ti -1c
.RI "void \fBheave\fP (const float &by)"
.br
.RI "\fIAdjusts the camera's y coordinate relative to its current position\&. \fP"
.ti -1c
.RI "void \fBpitch\fP (const float &by, const bool &fixed=false)"
.br
.RI "\fIpitch adjusts the x axis rotation; up/down look\&. \fP"
.ti -1c
.RI "void \fByaw\fP (const float &by, const bool &fixed=false)"
.br
.RI "\fIyaw adjusts the y axis rotation; left/right look\&. \fP"
.ti -1c
.RI "void \fBroll\fP (const float &by, const bool &fixed=false)"
.br
.RI "\fIroll adjusts the z axis rotation; tilt or lean left/right\&. \fP"
.ti -1c
.RI "void \fBmove\fP (const \fBCamera::Direction\fP &Dir)"
.br
.RI "\fImove instructs the camera to begin moving in the specified direction\&. \fP"
.ti -1c
.RI "void \fBstop\fP (const \fBCamera::Direction\fP &Dir)"
.br
.RI "\fIstop instructs the camera to stop moving in the specified direction\&. \fP"
.ti -1c
.RI "void \fBidle\fP (void)"
.br
.RI "\fIidle moves the camera forward in whichever directions it is configured to move in\&. \fP"
.ti -1c
.RI "void \fBaccel\fP (const \fBvec3\fP &accel)"
.br
.RI "\fIaccel takes an input vec2 which represents an acceleration, and applies it to the motion vectors with regards to the maximum acceleration and the maximum speed of the camera\&. \fP"
.ti -1c
.RI "float \fBx\fP (void) const "
.br
.RI "\fI\fBx()\fP returns the current position of the camera in model coordinates\&. \fP"
.ti -1c
.RI "float \fBy\fP (void) const "
.br
.RI "\fI\fBy()\fP returns the current position of the camera in model coordinates\&. \fP"
.ti -1c
.RI "float \fBz\fP (void) const "
.br
.RI "\fI\fBz()\fP returns the current position of the camera in model coordinates\&. \fP"
.ti -1c
.RI "\fBvec4\fP \fBpos\fP (void) const "
.br
.RI "\fI\fBpos()\fP gets the current camera position in model coordinates\&. \fP"
.ti -1c
.RI "virtual void \fBsend\fP (\fBObject::UniformEnum\fP which)"
.br
.RI "\fIsend will send a glsl variable to the shader\&. \fP"
.ti -1c
.RI "void \fBview\fP (void)"
.br
.RI "\fIview will instruct OpenGL of the viewport we want, and then send all of our current matrices to the shader for rendering\&. \fP"
.ti -1c
.RI "void \fBresetRotation\fP (void)"
.br
.RI "\fIresetRotation adjusts the camera's rotational state back to its default state (The Identity Matrix\&.) \fP"
.ti -1c
.RI "void \fBdraw\fP (void)"
.br
.RI "\fIdraw method: Render this object to the screen _buffer\&. \fP"
.ti -1c
.RI "void \fBbuffer\fP (void)"
.br
.RI "\fIbuffer all of our data: Vertices, TexUVs, Normals, Indices, Colors and Morph Buffers\&. \fP"
.ti -1c
.RI "void \fBbufferMorphOnly\fP (void)"
.br
.RI "\fIbuffer only the Morph-related buffers\&. \fP"
.ti -1c
.RI "void \fBdrawMode\fP (GLenum new_mode)"
.br
.RI "\fISelect a new OpenGL draw mode for this \fBObject\fP\&. \fP"
.ti -1c
.RI "void \fBtexture\fP (const char **filename)"
.br
.RI "\fIFIXME: This is a junk, nonflexible method\&. \fP"
.ti -1c
.RI "const std::string & \fBname\fP (void) const "
.br
.RI "\fIRetrieve the _name of this \fBObject\fP\&. \fP"
.ti -1c
.RI "virtual void \fBlink\fP (\fBUniformEnum\fP which, const std::string &\fBname\fP)"
.br
.RI "\fIlink a specified Uniform against the shader's variable _name\&. \fP"
.ti -1c
.RI "virtual GLuint \fBshader\fP (void)"
.br
.RI "\fIReturns the \fBObject\fP's current shader\&. \fP"
.ti -1c
.RI "virtual void \fBshader\fP (GLuint newShader)"
.br
.RI "\fISets the shader to be used by this object\&. \fP"
.ti -1c
.RI "void \fBanimation\fP (void(*anim_func)(\fBTransCache\fP &arg))"
.br
.RI "\fIApply an animation callback function to this \fBObject\fP\&. \fP"
.ti -1c
.RI "void \fBpropagate\fP (void)"
.br
.RI "\fIScene-graph changes are not automatically applied to children\&. \fP"
.ti -1c
.RI "\fBvec4\fP \fBposition\fP () const "
.br
.RI "\fIObtain the vec4 representative of the \fBObject\fP's current position in space\&. \fP"
.ti -1c
.RI "\fBObject\fP * \fBmorphTarget\fP () const "
.br
.RI "\fIRetrieve a pointer to this object's morph target\&. \fP"
.ti -1c
.RI "\fBObject\fP * \fBgenMorphTarget\fP (GLuint \fBshader\fP)"
.br
.RI "\fIInstantiate a new morphing target\&. \fP"
.ti -1c
.RI "float \fBmorphPercentage\fP () const "
.br
.RI "\fIRetrieve the morph Percentage of this object\&. \fP"
.ti -1c
.RI "void \fBmorphPercentage\fP (const float newPercentage)"
.br
.RI "\fISet the morph percentage of this \fBObject\fP\&. \fP"
.ti -1c
.RI "void \fBdestroyMorphTarget\fP ()"
.br
.RI "\fIObliterate the morph target for this object\&. \fP"
.ti -1c
.RI "int \fBnumberOfPoints\fP ()"
.br
.RI "\fIRetrieve the number of _vertices this object has\&. \fP"
.ti -1c
.RI "void \fBtextureID\fP (GLint newTextureID)"
.br
.RI "\fISet the \fBTexture\fP ID / \fBTexture\fP Unit for this \fBObject\fP\&. \fP"
.ti -1c
.RI "\fBObject\fP * \fBaddObject\fP (const std::string &objName, GLuint Object_Shader=0)"
.br
.RI "\fIaddObject creates a new \fBObject\fP with the given name and, optionally, a specified shader and adds it to the \fBScene\fP graph\&. \fP"
.ti -1c
.RI "void \fBdelObject\fP (const std::string &objName)"
.br
.RI "\fIdelObject will remove from the \fBScene\fP graph the object with the given name\&. \fP"
.ti -1c
.RI "void \fBdelObject\fP (void)"
.br
.RI "\fIdelObject with no parameters will delete the first \fBObject\fP in the \fBScene\fP\&. \fP"
.ti -1c
.RI "void \fBpopObject\fP (void)"
.br
.RI "\fIpopObject deletes the last \fBObject\fP in the \fBScene\fP\&. \fP"
.ti -1c
.RI "\fBObject\fP * \fBnext\fP (void)"
.br
.ti -1c
.RI "\fBObject\fP * \fBprev\fP (void)"
.br
.ti -1c
.RI "\fBObject\fP * \fBactive\fP (void) const "
.br
.ti -1c
.RI "\fBObject\fP * \fBoperator[]\fP (const std::string &objname)"
.br
.ti -1c
.RI "void \fBinsertObject\fP (\fBObject\fP *obj)"
.br
.RI "\fIRegister a created object with the scene graph\&. \fP"
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBAngel::vec4\fP > \fB_vertices\fP"
.br
.RI "\fIvertex buffer\&. \fP"
.ti -1c
.RI "std::vector< \fBAngel::vec3\fP > \fB_normals\fP"
.br
.RI "\fINormals buffer\&. \fP"
.ti -1c
.RI "std::vector< unsigned int > \fB_indices\fP"
.br
.RI "\fIDraw Order Index buffer\&. \fP"
.ti -1c
.RI "std::vector< \fBAngel::vec4\fP > \fB_colors\fP"
.br
.RI "\fIColors buffer\&. \fP"
.ti -1c
.RI "std::vector< \fBAngel::vec2\fP > \fB_texUVs\fP"
.br
.RI "\fI\fBTexture\fP Coordinates buffer\&. \fP"
.ti -1c
.RI "\fBTransCache\fP \fB_trans\fP"
.br
.RI "\fIThe _trans cache encompasses the current transformational state of this object\&. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBdeleteObject\fP (\fBObject\fP *obj)"
.br
.RI "\fIVery seriously delete a child object and free his memory\&. \fP"
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::string \fB_name\fP"
.br
.RI "\fI_name is used as an identifying handle for the object\&. \fP"
.ti -1c
.RI "GLuint \fB_vao\fP"
.br
.RI "\fIVertex Array \fBObject\fP handle identifying our buffers/object\&. \fP"
.ti -1c
.RI "GLuint \fB_buffer\fP [\fBNUM_BUFFERS\fP]"
.br
.RI "\fIHandles to our buffers (Vertices, TexUVs, etc\&.) \fP"
.ti -1c
.RI "GLenum \fB_drawMode\fP"
.br
.RI "\fIDrawing mode for this object\&. \fP"
.ti -1c
.RI "bool \fB_isTextured\fP"
.br
.RI "\fIIs this object textured? \fP"
.ti -1c
.RI "float \fB_morphPercentage\fP"
.br
.RI "\fIThe percentage of the morph\&. \fP"
.ti -1c
.RI "\fBObject\fP * \fB_morphTarget\fP"
.br
.RI "\fIA pointer to the object we wish to morph into\&. \fP"
.ti -1c
.RI "std::map< \fBObject::UniformEnum\fP, 
.br
std::string > \fB_uniformMap\fP"
.br
.RI "\fIA map between Uniform variable functions and the actual uniform variable names\&. \fP"
.ti -1c
.RI "std::vector< GLint > \fB_handles\fP"
.br
.RI "\fIHandles to Uniforms on the shader\&. \fP"
.ti -1c
.RI "GLint \fB_textureID\fP"
.br
.RI "\fIThe texture unit index this \fBObject\fP uses\&. \fP"
.ti -1c
.RI "std::list< \fBObject\fP * > \fB_list\fP"
.br
.RI "\fIFor the purposes of rapid propagation of scene-graph changes, \fBObject\fP pointers are stored in a regular flat list\&. \fP"
.ti -1c
.RI "std::map< std::string, \fBObject\fP * > \fB_map\fP"
.br
.RI "\fIFor the purposes of accessing named objects quickly, though, objects are also re-stored in an associative map\&. \fP"
.ti -1c
.RI "std::list< \fBObject\fP * >::iterator \fB_currentObj\fP"
.br
.RI "\fIWe keep an iterator on-hand that references what the scene considers to be it's active, current object\&. \fP"
.ti -1c
.RI "GLuint \fB_gShader\fP"
.br
.RI "\fIA handle to a shader program to be used as the default shader for new children objects added to the scene\&. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBadjustRotation\fP (const \fBmat4\fP &adjustment, const bool &fixed=false)"
.br
.RI "\fIadjustRotation is an internal function that rotates the camera\&. \fP"
.ti -1c
.RI "void \fBcommonInit\fP (void)"
.br
.RI "\fIcommonInit is a private function that initializes local object attributes\&. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBmat4\fP \fB_view\fP"
.br
.RI "\fIThe current view matrix (defaultly perspective) for this camera\&. \fP"
.ti -1c
.RI "\fBTransCache\fP \fB_ctm\fP"
.br
.RI "\fIThe Current \fBTransformation\fP state for this \fBCamera\fP\&. \fP"
.ti -1c
.RI "\fBViewType\fP \fB_currentView\fP"
.br
.RI "\fIThe current viewing mode type\&. \fP"
.ti -1c
.RI "GLfloat \fB_speed\fP"
.br
.RI "\fICurrent Speed of camera motion\&. \fP"
.ti -1c
.RI "\fBvec3\fP \fB_velocity\fP"
.br
.RI "\fICurrent Velocity of camera motion\&. \fP"
.ti -1c
.RI "GLfloat \fB_speed_cap\fP"
.br
.RI "\fICurrent Speed Capacity: (speed/MaxSpeed) \fP"
.ti -1c
.RI "GLfloat \fB_maxAccel\fP"
.br
.RI "\fIMaximum Acceleration Magnitude\&. \fP"
.ti -1c
.RI "GLfloat \fB_maxSpeed\fP"
.br
.RI "\fIMaximum Speed\&. \fP"
.ti -1c
.RI "GLfloat \fB_frictionMagnitude\fP"
.br
.RI "\fIFriction\&. \fP"
.ti -1c
.RI "GLfloat \fB_aspectRatio\fP"
.br
.RI "\fICurrent aspect ratio for certain perspectives\&. \fP"
.ti -1c
.RI "GLfloat \fB_fovy\fP"
.br
.RI "\fICurrent field-of-view angle for perspective view\&. \fP"
.ti -1c
.RI "\fBAngel::vec2\fP \fB_viewportSize\fP"
.br
.RI "\fI\fBCamera\fP's Drawbox Width and Height\&. \fP"
.ti -1c
.RI "\fBAngel::vec2\fP \fB_viewportPosition\fP"
.br
.RI "\fI\fBCamera\fP's Drawbox x,y Coordinate (Upper-Left Pixel) \fP"
.ti -1c
.RI "bool \fB_motion\fP [Camera::DIR_END]"
.br
.RI "\fIBooleans correlating to the different motion directions\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
The \fBCamera\fP class represents a logical camera in a model view, which posesses a current viewing angle and an absolute position in space as its state\&. 

\fBAuthor:\fP
.RS 4
John Huston, jhuston@cs.uml.edu 
.RE
.PP
\fBSince:\fP
.RS 4
16 Nov 2012
.RE
.PP
Functions are provided to adjust the rotation according to \fBpitch()\fP, \fByaw()\fP and \fBroll()\fP motions; \fBsurge()\fP, \fBsway()\fP, and \fBheave()\fP are provided to adjust position in space\&.
.PP
\fBmove()\fP, \fBstop()\fP, and \fBidle()\fP are provided to help the camera automatically move along the x, y, or z axes\&. 
.PP
Definition at line 37 of file Camera\&.hpp\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef enum \fBCamera::Direction\fP  \fBCamera::Direction\fP"

.PP
The Direction enumeration lists all of the possible directions the camera may travel in\&. 'BEGIN' and 'END' are special sentinel directions for the purposes of iteration, and are ignored by any functions that accept a Direction\&. 
.SS "typedef enum \fBCamera::Uniforms\fP  \fBCamera::Uniform\fP"

.PP
The glsl_var enumeration lists the various variables the \fBCamera\fP class is capable of sending to the shader\&. The NumGlslVars variable is a sentinel value that is ignored by any functions that accept a glsl_var\&. 
.SS "typedef const unsigned int \fBObject::UniformEnum\fP\fC [inherited]\fP"

.PP
The \fBObject\fP class takes advantage of child-extendible enumerations\&. We create an alias here for sake of ease\&. 
.PP
Definition at line 62 of file Object\&.hpp\&.
.SS "typedef std::map< \fBObject::UniformEnum\fP, std::string > \fBObject::UniformMap\fP\fC [inherited]\fP"

.PP
We store mappings of Uniform Enumerations, The desired function of the var, to strings, the names of the variables\&. This is utilized if we ever switch this object's shader, so we can re-associate with the correct uniform locations\&. 
.PP
Definition at line 70 of file Object\&.hpp\&.
.SS "typedef enum \fBCamera::ViewType\fP  \fBCamera::ViewType\fP"

.PP
The ViewType enumeration lists the various possibilities for the current viewing mode that can be switched between\&. The default is PERSPECTIVE\&. 
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBCamera::Direction\fP"

.PP
The Direction enumeration lists all of the possible directions the camera may travel in\&. 'BEGIN' and 'END' are special sentinel directions for the purposes of iteration, and are ignored by any functions that accept a Direction\&. 
.PP
Definition at line 47 of file Camera\&.hpp\&.
.SS "enum \fBCamera::Uniforms\fP"

.PP
The glsl_var enumeration lists the various variables the \fBCamera\fP class is capable of sending to the shader\&. The NumGlslVars variable is a sentinel value that is ignored by any functions that accept a glsl_var\&. 
.PP
Definition at line 73 of file Camera\&.hpp\&.
.SS "enum \fBCamera::ViewType\fP"

.PP
The ViewType enumeration lists the various possibilities for the current viewing mode that can be switched between\&. The default is PERSPECTIVE\&. 
.PP
Definition at line 63 of file Camera\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Camera::Camera (const std::string &name, GLuintgShader, floatx = \fC0\&.0\fP, floaty = \fC0\&.0\fP, floatz = \fC0\&.0\fP)"

.PP
Initialization Constructor; sets the x,y,z coordinates explicitly\&. \fBParameters:\fP
.RS 4
\fIname\fP The name of this Camera/Object\&. 
.br
\fIgShader\fP A handle to this camera's associated shader object\&. 
.br
\fIx\fP The initial x coordinate\&. 
.br
\fIy\fP The initial y coordinate\&. 
.br
\fIz\fP The initial z coordinate\&. 
.RE
.PP

.PP
Definition at line 45 of file Camera\&.cpp\&.
.SS "Camera::Camera (const std::string &name, GLuintgShader, \fBvec3\fP &in)"

.PP
Initialization Constructor, uses a vec3 as its initial coordinates\&. \fBParameters:\fP
.RS 4
\fIname\fP The name of this Camera/Object\&. 
.br
\fIgShader\fP A handle to this camera's associated shader object\&. 
.br
\fIin\fP A vec3 representing the initial coordinates\&. 
.RE
.PP

.PP
Definition at line 52 of file Camera\&.cpp\&.
.SS "Camera::Camera (const std::string &name, GLuintgShader, \fBvec4\fP &in)"

.PP
Initialization Constructor, uses a vec4 as its initial coordinates\&. \fBParameters:\fP
.RS 4
\fIname\fP The name of this Camera/Object\&. 
.br
\fIgShader\fP A handle to this camera's associated shader object\&. 
.br
\fIin\fP A vec4 representing the initial coordinates\&. The w component is ignored\&. 
.RE
.PP

.PP
Definition at line 58 of file Camera\&.cpp\&.
.SS "Camera::~Camera (void)\fC [virtual]\fP"

.PP
Default destructor\&. Defined only to allow inheritance\&. 
.PP
Definition at line 64 of file Camera\&.cpp\&.
.SH "Member Function Documentation"
.PP 
.SS "void Camera::accel (const \fBvec3\fP &accel)"

.PP
accel takes an input vec2 which represents an acceleration, and applies it to the motion vectors with regards to the maximum acceleration and the maximum speed of the camera\&. \fBParameters:\fP
.RS 4
\fIaccel\fP The vec3 which represents the (x,y,z) acceleration, where x,y,z are [-1,1]\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 223 of file Camera\&.cpp\&.
.SS "\fBObject\fP * Scene::addObject (const std::string &objName, GLuintshader = \fC0\fP)\fC [inherited]\fP"

.PP
addObject creates a new \fBObject\fP with the given name and, optionally, a specified shader and adds it to the \fBScene\fP graph\&. If no shader is given, a default shader MUST have been specified for the \fBScene\fP prior to the call\&.
.PP
\fBParameters:\fP
.RS 4
\fIobjName\fP The name of the new \fBObject\fP to add\&. 
.br
\fIObject_Shader\fP The shader that should be used to render this object\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the new \fBObject\fP\&. 
.RE
.PP

.PP
Definition at line 77 of file Scene\&.cpp\&.
.SS "void Camera::adjustFieldOfView (const float &by)"

.PP
adjustFieldOfView adjusts the field of view angle up or down by an amount\&. \fBParameters:\fP
.RS 4
\fIby\fP The float to adjust the fieldOfView angle by\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 392 of file Camera\&.cpp\&.
.SS "void Camera::adjustRotation (const \fBmat4\fP &adjustment, const bool &fixed = \fCfalse\fP)\fC [private]\fP"

.PP
adjustRotation is an internal function that rotates the camera\&. Technically, any transformation, not just a rotation, is possible\&. 
.PP
\fBParameters:\fP
.RS 4
\fIadjustment\fP The 4x4 matrix to transform the CTM by\&. 
.br
\fIfixed\fP Should this rotation be fixed about the origin? 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 148 of file Camera\&.cpp\&.
.SS "void Object::animation (void(*)(\fBTransCache\fP &arg)anim_func)\fC [inherited]\fP"

.PP
Apply an animation callback function to this \fBObject\fP\&. Works once only: Does not save the function or automatically run on idle\&. 
.PP
\fBParameters:\fP
.RS 4
\fIanim_func\fP The transformation/animation function to apply\&. 
.RE
.PP

.PP
Definition at line 443 of file Object\&.cpp\&.
.SS "void Camera::changePerspective (const \fBViewType\fP &vType)"

.PP
changePerspective changes the current perspective of the camera\&. \fBParameters:\fP
.RS 4
\fIvType\fP Which perspective to use\&. see enum ViewType for possibilities\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 359 of file Camera\&.cpp\&.
.SS "void Camera::commonInit (void)\fC [private]\fP"

.PP
commonInit is a private function that initializes local object attributes\&. It should be called by all available constructors\&. 
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 19 of file Camera\&.cpp\&.
.SS "void Scene::deleteObject (\fBObject\fP *obj)\fC [protected]\fP, \fC [inherited]\fP"

.PP
Very seriously delete a child object and free his memory\&. deleteObject is the actual implementation function that will remove an \fBObject\fP from the \fBScene\fP list and \fBScene\fP map, then free the object\&.
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP The object to delete\&.
.br
\fIobj\fP The pointer to the object to free\&. 
.RE
.PP

.PP
Definition at line 129 of file Scene\&.cpp\&.
.SS "void Scene::delObject (const std::string &objName)\fC [inherited]\fP"

.PP
delObject will remove from the \fBScene\fP graph the object with the given name\&. \fBParameters:\fP
.RS 4
\fIobjName\fP Name of the \fBObject\fP to delete\&. 
.RE
.PP

.PP
Definition at line 99 of file Scene\&.cpp\&.
.SS "void Camera::dPos (const float &x, const float &y, const float &z)"

.PP
Moves the camera along the x, y, and z axes\&. \fBParameters:\fP
.RS 4
\fIx\fP the x-axis displacement\&. 
.br
\fIy\fP the y-axis displacement\&. 
.br
\fIz\fP the z-axis displacement\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 131 of file Camera\&.cpp\&.
.SS "void Camera::dPos (const \fBvec3\fP &by)"

.PP
Moves the camera along the x, y, and z axes\&. \fBParameters:\fP
.RS 4
\fIby\fP A vec3 containing the x, y, and z axis displacements\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 140 of file Camera\&.cpp\&.
.SS "void Camera::dPos (const \fBvec4\fP &by)"

.PP
Moves the camera along the x, y, and z axes\&. \fBParameters:\fP
.RS 4
\fIby\fP A vec4 containing the x, y, and z axis displacements\&. The w component is ignored\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 144 of file Camera\&.cpp\&.
.SS "void Object::drawMode (GLenumnew_mode)\fC [inherited]\fP"

.PP
Select a new OpenGL draw mode for this \fBObject\fP\&. Can be GL_LINES, GL_LINE_LOOP, GL_TRIANGLES, etc\&. 
.PP
\fBSee Also:\fP
.RS 4
http://www.opengl.org/wiki/Primitive 
.RE
.PP
\fBParameters:\fP
.RS 4
\fInew_mode\fP The primitive rendering mode to use\&. 
.RE
.PP

.PP
Definition at line 269 of file Object\&.cpp\&.
.SS "void Camera::dX (const float &by, const bool &update = \fCtrue\fP)"

.PP
Moves the camera along the x axis\&. \fBParameters:\fP
.RS 4
\fIby\fP The float value of the x-axis displacement\&. 
.br
\fIupdate\fP A boolean indicating whether or not to update the shader\&. update defaults to true\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
void\&. 
.RE
.PP

.PP
Definition at line 119 of file Camera\&.cpp\&.
.SS "void Camera::dY (const float &by, const bool &update = \fCtrue\fP)"

.PP
Moves the camera along the y axis\&. \fBParameters:\fP
.RS 4
\fIby\fP The float value of the y-axis displacement\&. 
.br
\fIupdate\fP A boolean indicating whether or not to update the shader\&. update defaults to true\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 123 of file Camera\&.cpp\&.
.SS "void Camera::dZ (const float &by, const bool &update = \fCtrue\fP)"

.PP
Moves the camera along the z axis\&. \fBParameters:\fP
.RS 4
\fIby\fP The float value of the z-axis displacement\&. 
.br
\fIupdate\fP A boolean indicating whether or not to update the shader\&. update defaults to true\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 127 of file Camera\&.cpp\&.
.SS "void Camera::fieldOfView (const float &fovy)"

.PP
fieldOfView sets the current camera Field-of-view angle\&. This function will send the new perspective matrix to the shader\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfovy\fP The new field of view angle\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 354 of file Camera\&.cpp\&.
.SS "float Camera::fieldOfView (void) const"

.PP
\fBfieldOfView()\fP gets the current camera Field-of-view angle\&. \fBReturns:\fP
.RS 4
A float that is the y axis viewing angle\&. 
.RE
.PP

.PP
Definition at line 350 of file Camera\&.cpp\&.
.SS "\fBObject\fP * Object::genMorphTarget (GLuintshader)\fC [inherited]\fP"

.PP
Instantiate a new morphing target\&. \fBParameters:\fP
.RS 4
\fIshader\fP The shader to use for the new morphing target\&. NOT USED for rendering the object, but Objects cannot be instantiated without a shader, so here it is\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the newly created target\&. 
.RE
.PP

.PP
Definition at line 503 of file Object\&.cpp\&.
.SS "void Camera::heave (const float &by)"

.PP
Adjusts the camera's y coordinate relative to its current position\&. Positive values move the camera up, and negative values move the camera down\&. 
.PP
\fBParameters:\fP
.RS 4
\fIby\fP The float to adjust the y coordinate by\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 194 of file Camera\&.cpp\&.
.SS "void Camera::idle (void)"

.PP
idle moves the camera forward in whichever directions it is configured to move in\&. Call it in the glut idle function\&. 
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 280 of file Camera\&.cpp\&.
.SS "void Scene::insertObject (\fBObject\fP *obj)\fC [inherited]\fP"

.PP
Register a created object with the scene graph\&. \fBParameters:\fP
.RS 4
\fIname\fP The name of the object (For the associative map), 
.br
\fIobj\fP The \fBObject\fP pointer to add to the scene\&. 
.RE
.PP

.PP
Definition at line 118 of file Scene\&.cpp\&.
.SS "void Object::link (\fBUniformEnum\fPwhich, const std::string &name)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
link a specified Uniform against the shader's variable _name\&. \fBParameters:\fP
.RS 4
\fIwhich\fP The Uniform to link\&. 
.br
\fIname\fP The variable _name on the shader\&. 
.RE
.PP

.PP
Definition at line 345 of file Object\&.cpp\&.
.SS "float Object::morphPercentage (void) const\fC [inherited]\fP"

.PP
Retrieve the morph Percentage of this object\&. \fBReturns:\fP
.RS 4
The morph percentage, as a float\&. 
.RE
.PP

.PP
Definition at line 515 of file Object\&.cpp\&.
.SS "void Object::morphPercentage (const floatnewPercentage)\fC [inherited]\fP"

.PP
Set the morph percentage of this \fBObject\fP\&. \fBParameters:\fP
.RS 4
\fInewPercentage\fP The new morphing percentage\&. 
.RE
.PP

.PP
Definition at line 524 of file Object\&.cpp\&.
.SS "\fBObject\fP * Object::morphTarget (void) const\fC [inherited]\fP"

.PP
Retrieve a pointer to this object's morph target\&. \fBReturns:\fP
.RS 4
An \fBObject\fP pointer to the morph target\&. 
.RE
.PP

.PP
Definition at line 489 of file Object\&.cpp\&.
.SS "void Camera::move (const \fBCamera::Direction\fP &Dir)"

.PP
move instructs the camera to begin moving in the specified direction\&. \fBParameters:\fP
.RS 4
\fIDir\fP The direction in which to move\&. Can be any direction in the enumerated type \fBCamera::Direction\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 272 of file Camera\&.cpp\&.
.SS "const std::string & Object::name (void) const\fC [inherited]\fP"

.PP
Retrieve the _name of this \fBObject\fP\&. \fBReturns:\fP
.RS 4
The _name of this \fBObject\fP\&. 
.RE
.PP

.PP
Definition at line 333 of file Object\&.cpp\&.
.SS "int Object::numberOfPoints (void)\fC [inherited]\fP"

.PP
Retrieve the number of _vertices this object has\&. \fBReturns:\fP
.RS 4
An integer representing the number of vertices the object has\&. 
.RE
.PP

.PP
Definition at line 544 of file Object\&.cpp\&.
.SS "void Camera::pitch (const float &by, const bool &fixed = \fCfalse\fP)"

.PP
pitch adjusts the x axis rotation; up/down look\&. A positive value represents looking up, while a negative value represents looking down\&. 
.PP
\fBParameters:\fP
.RS 4
\fIby\fP A float, in degrees, to adjust the pitch by\&. 
.br
\fIfixed\fP Should this rotation be fixed about the origin? 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 198 of file Camera\&.cpp\&.
.SS "void Camera::pos (const float &x, const float &y, const float &z, const bool &update = \fCtrue\fP)"

.PP
Sets the absolute position of the camera\&. \fBParameters:\fP
.RS 4
\fIx\fP The new x coordinate of the camera\&. 
.br
\fIy\fP The new y coordinate of the camera\&. 
.br
\fIz\fP The new z coordinate of the camera\&. 
.br
\fIupdate\fP Whether or not to update the shader with the new coordinates\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 99 of file Camera\&.cpp\&.
.SS "void Camera::pos (const \fBvec3\fP &in, const bool &update = \fCtrue\fP)"

.PP
Sets the absolute position of the camera\&. \fBParameters:\fP
.RS 4
\fIin\fP A vec3 containing the x, y, and z coordinates to set the camera to\&. 
.br
\fIupdate\fP Whether or not to update the shader with the new coordinates\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 115 of file Camera\&.cpp\&.
.SS "void Camera::pos (const \fBvec4\fP &in, const bool &update = \fCtrue\fP)"

.PP
Sets the absolute position of the camera\&. \fBParameters:\fP
.RS 4
\fIin\fP A vec4 containing the x, y, and z coordinates to set the camera to\&. The w coordinate is ignored\&. 
.br
\fIupdate\fP Whether or not to update the shader with the new coordinates\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 111 of file Camera\&.cpp\&.
.SS "\fBvec4\fP Camera::pos (void) const"

.PP
\fBpos()\fP gets the current camera position in model coordinates\&. \fBReturns:\fP
.RS 4
A vec4 that represents the current camera coordinates\&. 
.RE
.PP

.PP
Definition at line 346 of file Camera\&.cpp\&.
.SS "\fBvec4\fP Object::position (void) const\fC [inherited]\fP"

.PP
Obtain the vec4 representative of the \fBObject\fP's current position in space\&. \fBReturns:\fP
.RS 4
vec4 representing the \fBObject\fP's position in space\&. 
.RE
.PP

.PP
Definition at line 478 of file Object\&.cpp\&.
.SS "void Object::propagate (void)\fC [inherited]\fP"

.PP
Scene-graph changes are not automatically applied to children\&. For efficiency reasons, you need to call \fBpropagate()\fP manually\&. 
.PP
Definition at line 452 of file Object\&.cpp\&.
.SS "void Camera::refreshPerspective (void)"

.PP
refreshPerspective re-generates the current view/perspective matrix of the camera\&. This function should be called after physical or virtual (viewport) screen resizes\&. 
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 366 of file Camera\&.cpp\&.
.SS "void Camera::resetRotation (void)"

.PP
resetRotation adjusts the camera's rotational state back to its default state (The Identity Matrix\&.) \fBReturns:\fP
.RS 4
void\&. 
.RE
.PP

.PP
Definition at line 446 of file Camera\&.cpp\&.
.SS "void Camera::roll (const float &by, const bool &fixed = \fCfalse\fP)"

.PP
roll adjusts the z axis rotation; tilt or lean left/right\&. A positive value represents leaning right, while a negative value represents leaning left\&. 
.PP
\fBParameters:\fP
.RS 4
\fIby\fP A float, in degrees, to adjust the roll by\&. 
.br
\fIfixed\fP Should this rotation be fixed about the origin? 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 219 of file Camera\&.cpp\&.
.SS "void Camera::send (\fBObject::UniformEnum\fPwhich)\fC [virtual]\fP"

.PP
send will send a glsl variable to the shader\&. \fBParameters:\fP
.RS 4
\fIwhich\fP The parameter to send\&. Can be any from enum glsl_var\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Reimplemented from \fBObject\fP\&.
.PP
Definition at line 403 of file Camera\&.cpp\&.
.SS "GLuint Object::shader (void)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Returns the \fBObject\fP's current shader\&. Defined because C++ will not let you overload an overrided function, without re-overloading it in the derived class\&.
.PP
\fBReturns:\fP
.RS 4
a GLuint handle to the shader program used by this \fBObject\fP\&. 
.RE
.PP

.PP
Reimplemented from \fBScene\fP\&.
.PP
Definition at line 406 of file Object\&.cpp\&.
.SS "void Object::shader (GLuintnewShader)\fC [virtual]\fP, \fC [inherited]\fP"

.PP
Sets the shader to be used by this object\&. Triggers a query of the shader program, for the locations of the Uniform locations that the object needs\&.
.PP
\fBParameters:\fP
.RS 4
\fInewShader\fP a GLuint handle to the shader program to use\&.
.RE
.PP
\fBReturns:\fP
.RS 4
None\&. 
.RE
.PP

.PP
Reimplemented from \fBScene\fP\&.
.PP
Definition at line 422 of file Object\&.cpp\&.
.SS "void Camera::stop (const \fBCamera::Direction\fP &Dir)"

.PP
stop instructs the camera to stop moving in the specified direction\&. \fBParameters:\fP
.RS 4
\fIDir\fP The direction in which to stop moving\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 276 of file Camera\&.cpp\&.
.SS "void Camera::surge (const float &by)"

.PP
Adjusts the camera's z coordinate relative to its current position\&. Positive values move the camera forward, and negative values move the camera backward\&. Note that the camera uses model coordinates internally, so moving forward will increase the camera's z position negatively\&. 
.PP
\fBParameters:\fP
.RS 4
\fIby\fP The float to adjust the z coordinate by\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 190 of file Camera\&.cpp\&.
.SS "void Camera::sway (const float &by)"

.PP
Adjusts the camera's x coordinate relative to its current position\&. Negative values move the camera left, and positive values move the camera right\&. 
.PP
\fBParameters:\fP
.RS 4
\fIby\fP The float to adjust the x coordinate by\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 186 of file Camera\&.cpp\&.
.SS "void Object::texture (const char **filename)\fC [inherited]\fP"

.PP
FIXME: This is a junk, nonflexible method\&. It would be better if you didn't think of this as being here\&.
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP an array of strings to load textures from\&. 
.RE
.PP

.PP
Definition at line 279 of file Object\&.cpp\&.
.SS "void Object::textureID (GLintnewTextureID)\fC [inline]\fP, \fC [inherited]\fP"

.PP
Set the \fBTexture\fP ID / \fBTexture\fP Unit for this \fBObject\fP\&. \fBParameters:\fP
.RS 4
\fInewTextureID\fP The new \fBTexture\fP Unit ID/Index for this \fBObject\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
None\&. 
.RE
.PP

.PP
Definition at line 244 of file Object\&.hpp\&.
.SS "void Camera::view (void)"

.PP
view will instruct OpenGL of the viewport we want, and then send all of our current matrices to the shader for rendering\&. \fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 434 of file Camera\&.cpp\&.
.SS "void Camera::viewport (size_t_X, size_t_Y, size_t_width, size_t_height)"

.PP
viewport instructs this camera what his expected drawing window will be\&. This allows the camera to generate his viewing matrices with the correct aspect ratio\&. 
.PP
\fBParameters:\fP
.RS 4
\fI_X\fP The x coordinate of the lower-left corner of our viewport\&. 
.br
\fI_Y\fP the y coordinate of the lower-left corner of our viewport\&. 
.br
\fI_width\fP The width of our viewport\&. 
.br
\fI_height\fP the height of our viewport\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 396 of file Camera\&.cpp\&.
.SS "void Camera::x (const float &in, const bool &update = \fCtrue\fP)"

.PP
Sets the x coordinate of the camera\&. \fBParameters:\fP
.RS 4
\fIin\fP The new x coordinate of the camera\&. 
.br
\fIupdate\fP Whether or not to update the shader with the new coordinates\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 68 of file Camera\&.cpp\&.
.SS "float Camera::x (void) const"

.PP
\fBx()\fP returns the current position of the camera in model coordinates\&. \fBReturns:\fP
.RS 4
The current x coordinate of the camera in model coordinates\&. 
.RE
.PP

.PP
Definition at line 334 of file Camera\&.cpp\&.
.SS "void Camera::y (const float &in, const bool &update = \fCtrue\fP)"

.PP
Sets the y coordinate of the camera\&. \fBParameters:\fP
.RS 4
\fIin\fP The new y coordinate of the camera\&. 
.br
\fIupdate\fP Whether or not to update the shader with the new coordinates\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 79 of file Camera\&.cpp\&.
.SS "float Camera::y (void) const"

.PP
\fBy()\fP returns the current position of the camera in model coordinates\&. \fBReturns:\fP
.RS 4
The current y coordinate of the camera in model coordinates\&. 
.RE
.PP

.PP
Definition at line 338 of file Camera\&.cpp\&.
.SS "void Camera::yaw (const float &by, const bool &fixed = \fCfalse\fP)"

.PP
yaw adjusts the y axis rotation; left/right look\&. A positive value represents looking right, while a negative value represents looking left\&. 
.PP
\fBParameters:\fP
.RS 4
\fIby\fP A float, in degrees, to adjust the yaw by\&. 
.br
\fIfixed\fP Should this rotation be fixed about the origin? 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 209 of file Camera\&.cpp\&.
.SS "void Camera::z (const float &in, const bool &update = \fCtrue\fP)"

.PP
Sets the z coordinate of the camera\&. \fBParameters:\fP
.RS 4
\fIin\fP The new z coordinate of the camera\&. 
.br
\fIupdate\fP Whether or not to update the shader with the new coordinates\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Void\&. 
.RE
.PP

.PP
Definition at line 89 of file Camera\&.cpp\&.
.SS "float Camera::z (void) const"

.PP
\fBz()\fP returns the current position of the camera in model coordinates\&. \fBReturns:\fP
.RS 4
The current z coordinate of the camera in model coordinates\&. 
.RE
.PP

.PP
Definition at line 342 of file Camera\&.cpp\&.
.SH "Member Data Documentation"
.PP 
.SS "GLfloat Camera::_aspectRatio\fC [private]\fP"

.PP
Current aspect ratio for certain perspectives\&. 
.PP
Definition at line 428 of file Camera\&.hpp\&.
.SS "std::vector< \fBAngel::vec4\fP > Object::_colors\fC [inherited]\fP"

.PP
Colors buffer\&. 
.PP
Definition at line 256 of file Object\&.hpp\&.
.SS "\fBTransCache\fP Camera::_ctm\fC [private]\fP"

.PP
The Current \fBTransformation\fP state for this \fBCamera\fP\&. 
.PP
Definition at line 404 of file Camera\&.hpp\&.
.SS "\fBViewType\fP Camera::_currentView\fC [private]\fP"

.PP
The current viewing mode type\&. 
.PP
Definition at line 407 of file Camera\&.hpp\&.
.SS "GLenum Object::_drawMode\fC [protected]\fP, \fC [inherited]\fP"

.PP
Drawing mode for this object\&. GL_TRIANGLES, GL_LINE_LOOP, etc\&. 
.PP
Definition at line 278 of file Object\&.hpp\&.
.SS "GLfloat Camera::_fovy\fC [private]\fP"

.PP
Current field-of-view angle for perspective view\&. 
.PP
Definition at line 431 of file Camera\&.hpp\&.
.SS "GLfloat Camera::_frictionMagnitude\fC [private]\fP"

.PP
Friction\&. Should be less than MaxAccel\&. 
.PP
Definition at line 425 of file Camera\&.hpp\&.
.SS "std::vector< GLint > Object::_handles\fC [protected]\fP, \fC [inherited]\fP"

.PP
Handles to Uniforms on the shader\&. Protected to allow derived classes to extend it as needed\&. 
.PP
Definition at line 307 of file Object\&.hpp\&.
.SS "std::vector< unsigned int > Object::_indices\fC [inherited]\fP"

.PP
Draw Order Index buffer\&. If not used, engine assumes GL_DRAW_ARRAYS\&. 
.PP
Definition at line 254 of file Object\&.hpp\&.
.SS "std::map< std::string, \fBObject\fP* > Scene::_map\fC [protected]\fP, \fC [inherited]\fP"

.PP
For the purposes of accessing named objects quickly, though, objects are also re-stored in an associative map\&. It's a little superfluous, but here it is! 
.PP
Definition at line 127 of file Scene\&.hpp\&.
.SS "float Object::_morphPercentage\fC [protected]\fP, \fC [inherited]\fP"

.PP
The percentage of the morph\&. 0\&.0 means 100% the original, current object\&. 100\&.0 means 100% the new, targeted object\&. 
.PP
Definition at line 289 of file Object\&.hpp\&.
.SS "bool Camera::_motion[Camera::DIR_END]\fC [private]\fP"

.PP
Booleans correlating to the different motion directions\&. 
.PP
Definition at line 440 of file Camera\&.hpp\&.
.SS "std::string Object::_name\fC [protected]\fP, \fC [inherited]\fP"

.PP
_name is used as an identifying handle for the object\&. 
.PP
Definition at line 269 of file Object\&.hpp\&.
.SS "std::vector< \fBAngel::vec3\fP > Object::_normals\fC [inherited]\fP"

.PP
Normals buffer\&. 
.PP
Definition at line 252 of file Object\&.hpp\&.
.SS "GLfloat Camera::_speed\fC [private]\fP"

.PP
Current Speed of camera motion\&. 
.PP
Definition at line 410 of file Camera\&.hpp\&.
.SS "std::vector< \fBAngel::vec2\fP > Object::_texUVs\fC [inherited]\fP"

.PP
\fBTexture\fP Coordinates buffer\&. 
.PP
Definition at line 258 of file Object\&.hpp\&.
.SS "std::map< \fBObject::UniformEnum\fP, std::string > Object::_uniformMap\fC [protected]\fP, \fC [inherited]\fP"

.PP
A map between Uniform variable functions and the actual uniform variable names\&. Used when linking against a shader\&. 
.PP
Definition at line 300 of file Object\&.hpp\&.
.SS "GLuint Object::_vao\fC [protected]\fP, \fC [inherited]\fP"

.PP
Vertex Array \fBObject\fP handle identifying our buffers/object\&. 
.PP
Definition at line 272 of file Object\&.hpp\&.
.SS "\fBvec3\fP Camera::_velocity\fC [private]\fP"

.PP
Current Velocity of camera motion\&. 
.PP
Definition at line 413 of file Camera\&.hpp\&.
.SS "std::vector< \fBAngel::vec4\fP > Object::_vertices\fC [inherited]\fP"

.PP
vertex buffer\&. 
.PP
Definition at line 250 of file Object\&.hpp\&.
.SS "\fBmat4\fP Camera::_view\fC [private]\fP"

.PP
The current view matrix (defaultly perspective) for this camera\&. 
.PP
Definition at line 401 of file Camera\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for HyperGrafx from the source code\&.
